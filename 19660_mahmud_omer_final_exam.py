# -*- coding: utf-8 -*-
"""19660_Mahmud_Omer_Final_Exam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LgoKbDis0XFRp36YgES_XuQfAyz5XhTN
"""

# 1.	Write a function as a decorator of other function calls for the following operations

def  trc1(g):
       def f(n) :
          return g(n)
       return f
    
@trc1
def  sqr(x):
    return x*x

@trc1
def  sum_sqr(n):
    sum = 0
    for i in range(n+1):
       sum += sqr(i)
    return sum 

print(sqr(3))
print(sum_sqr(3))

#2. def  verify_add(m, ls):

"""Returns True if addition of any two different elements in ls is m.
    >>> verify_add (100, [1, 2, 3, 4, 5])
    False
    >>> verify_add (7, [1, 2, 3, 4, 2])
    True				# 7 = 3 +4
    >>> verify_add (10, [5, 5])
    False				
    >>> verify_add (151, range(0, 200000, 3))
    False
   	>>>verify_add(50004, range(0, 200000, 4))
    True				# 50004 = 50000 + 4
   """
#ANS

def verify_add(m, ls):
    elements = {}
    for index, value in enumerate(ls):
        if m - value in elements:
            return True
        else:
            elements[value] = index
    return False 

print(verify_add(100, [1, 2, 3, 4, 5]))
print(verify_add(7, [1, 2, 3, 4, 2]))
print(verify_add(10, [5, 5]))
print(verify_add(151, range(0, 200000, 3)))
print(verify_add(50004, range(0, 200000, 4)))

#3.	Write a function to implement deep-reverse for taking a (possibly deep)
# tuple argument and reverses it including deep tuple element. 

# def  deep_rvrs(tup):
"""Reverses tuple with possible tuple elements
    >>> a = (11, 12, 13, 14) 
	 >>> deep_rvrs (a)
    (14, 13, 12, 11)
    >>>tpl = (11, (12, (13,113), 14), 15)
    >>> deep_rvrs (tpl)
    (15, (14, (113, 13), 12), 11))
    """
#ANS
def deep_rvrs(t):
    return tuple(deep_rvrs(x) if isinstance(x, tuple) else x for x in reversed(t))

  
a = (11, 12, 13, 14)
print(deep_rvrs(a))

tpl = (11, (12, (13,113), 14), 15)
print(deep_rvrs (tpl))

#4
class Fibonacci():
    """A Fibonacci number.
    >>>a = Fibonacci():
    >>>a
    0
    >>>a.nxt()
    1
    >>>a.nxt().nxt()
    1
    >>>a.nxt().nxt().nxt()
    2
    >>>a.nxt().nxt().nxt().nxt()
    3
    >>>a.nxt().nxt().nxt().nxt().nxt()
    5
    >>>a.nxt.nxt().nxt().nxt().nxt().nxt()
    8
    """

    def __init__(self):
        self.val = 0
        self.next_val = 1

    def nxt(self):
        result = Fibonacci()
        result.val = self.next_val
        result.next_val = self.val + self.next_val
        return result

    def __repr__(self):
        return str(self.val)


# Testing the class here. ignore/remove the code below if not required
a = Fibonacci()
print(a)
print(a.nxt())
print(a.nxt().nxt())
print(a.nxt().nxt().nxt())
print(a.nxt().nxt().nxt().nxt())
print(a.nxt().nxt().nxt().nxt().nxt())
print(a.nxt().nxt().nxt().nxt().nxt().nxt())

#5
class Student:

    def __init__(self, name, courses):
        self.name = name
        self.courses = courses

    def __str__(self):
         return str(self.courses)
    def __repr__(self):
          return str(self)
    def __add__(self, st):
      return Student("", self.courses + st.courses)
    def __lt__(self, st):
          return self.courses < st.courses
    def __eq__(self, st):
          return self.courses == st.courses
    def __ne__(self, st):
           return self.courses != st.courses
    def __gt__(self, st):
        return self.name > st.courses

a = Student('Peter', 3)
b= Student('Mike', 4)
c = Student('John',5)
d = Student('Kelvin', 3)

print(a+b+d)
print(a!=d)
print( b<c)