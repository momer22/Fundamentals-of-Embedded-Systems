# -*- coding: utf-8 -*-
"""19660_Mahmud_Omer_hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-kub7JA4cz7caaqrjrAzCdemi9wlKihT
"""

#1.	Write a function to take a positive integer x as input and print all ways of forming positive integer x by multiplying two positive integers together, ordered by the first term. Then, return whether the sum of the proper divisors of x is greater than x. 

#def abndnt(n):
"""
   >>> abndnt(12) 	# 1 + 2 + 3 + 4 + 6 is 16, which is larger than 12 
   1 * 12 
   2 * 6 
   3 * 4 
   True 
  >>> abndnt (14)	 # 1 + 2 + 7 is 10, which is not larger than 14 
   1 * 14 
   2 * 7 
   False 
   >>> abndnt (16) 
   1 * 16 
   2 * 8 
   4 * 4 
   False 
   >>> abndnt (20) 
   1 * 20 
 		   2 * 10 
   4 * 5 
   True 
   >>> abndnt (22) 
   1 * 22 
   2 * 11 
   False 
   >>> r = abndnt(24) 
   1 * 24 
   2 * 12 
   3 * 8 
   4 * 6 
   >>> r 
  True
 """
#ANS
def abndnt(n):
  divisors = []
  sum = 0
  for i in range(1,n):
      if n%i == 0:
         if(i<=n/i):
           print(i,"*",int(n/i))
         divisors.append(i)
         sum += i 
  if sum >n:
     return True 
  return False 
print(abndnt(12))
print(abndnt(14))	
print(abndnt(16))
print(abndnt(20))
print(abndnt(22))
r = abndnt(24) 
print(r)

#2.	Create a high-order function to implement the following calculations

#def adder(f1, f2):
"""
    Return a function that takes in a single variable x, and returns
    f1(x) + f2(x). You can assume the result of f1(x) and f2(x) can be
    added together, and they both take in one argument.

    def  identity(n):
	return n 
    
   def  square(n):
return n**2

    >>> a1 = adder(identity, square)		 
    >>> a1(4)					# x + x^2 = 4 + 4^2 = 20
    20
    >>> a2 = adder(a1, identity)     		
    >>> a2(4)	    # a1(4) + identity(4) = identity(4)+ square(4)+ identity(4)
    24						 
    >>> a2(5)
    35
    >>> a3 = adder(a1, a2)           # (x + x^2) + (x + x^2 + x)
    >>> a3(4)
    44
    """
def  identity(n):
	return n 
    
def  square(n):
  return n**2

def adder(f1, f2):
   def f(x):
      return f1(x) + f2(x)
   return f 

a1 = adder(identity, square)
print(a1(4))

a2 = adder(a1, identity) 
print(a2(4))

print(a2(5))
a3 = adder(a1, a2)           
print(a3(4))

#3.	What is printed? And explain WHY statement by statement
from operator import add
def absx(x):
  return abs(x)
def negx(x):
  return -1*x

def   combine_funcs(op):
    def   combined(f, g):
        def   val(x):
            return   op(f(x), g(x))
        return   val
    return   combined

add_func = combine_funcs(add)
h = add_func(absx, negx)
print(h(-5))

##ANS
# step 1: add(....) function is imported from operator 
# step 2: function absx(x) is defined 
# step 3: function negx(x) is defined 
# step 4: function combine_funcs(op) is defined 
# step 5: assignment: add_func = combine_funcs(add)->function call 
# step 6: combine_funcs(add)
# step 7: add function is called 
# step 8: function combined(f, g) is called 
# step 9: return the function combined  to add_func 
# step 10: add_func(absx,negx) is called 
# step 11: add_func calls combined(absx,negx) function  
# step 12: function val(x) is defined, and Val function is returned 
# step 13: h is assigned to val(absx,negx), which is the function returned from add_func(absx,negx)
# step 14: h(-5) = add(abs(-5),neg(-5)) = 5 + 5 = 10 is printed

"""[code follow graph ](https://drive.google.com/file/d/1Ox7Gd5cIKgVPukyoZOnRz9nfPp8bm_kf/view?usp=sharing)"""

#4.	Write a function to implement intersects, which takes a one-argument function "f" and argument "x", returns a function "g". It returns True if f(x)=g(x), otherwise False. 

#def   intscts(f, x): 
"""Returns a function that returns if f intersects g at x. 

  >>> at_three = intscts (square, 3) 
  >>> at_three(triple) 		# triple(3) == square(3) 
  True 
  >>> at_three(increment) 
  False 
  >>> at_one = intscts (identity, 1) 
  >>> at_one(square) 
  True 
  >>> at_one(triple) 
  False 
  """
#ANS
def square(n):
  return n*n
def triple(n):
   return 3*n 
def increment(n):
   return n+1
def identity(n):
  return 1*n

def intscts(f,x):
   def g(h):
     if h(x) == f(x):
       return True 
     return False 
   return g
at_three = intscts (square, 3) 
print(at_three(triple))
print(at_three(increment))
at_one = intscts (identity, 1) 
print(at_one(square))
print(at_one(triple))

#5.	Complete the following function 
#def     f(): 
""" 
  >>> f()()(3)() 
  3 
  """
# Your Program
def  f(): 
   def f():
     def f(n):
       def f():
         return n
       return f
     return f 
   return f 
# Your Program
f()()(3)()

#6.	Define a function "smth" that takes a function g and a value to use
# for dx and returns a function that computes the smoothed version of g.
# Do NOT use any "def" statements inside of "smth", but use "lambda" 
# expressions instead. 
# def    smth(g, dx): 
"""Returns the smoothed version of g, f where 
   f(x) = (g(x - dx) + g(x) + g(x + dx)) / 3 

   >>> square = lambda x: x ** 2 
   >>> round(smth(square, 1)(0), 3) 
   0.667 
   """
#ANS

def smth(g, dx):
   return lambda x: (g(x-dx)+g(x) +g(x+dx))/3
   
square = lambda x: x**2
smoothed = smth(square,1)
round(smth(square,1)(0),(3))

#7.	Define a function "cyc" that takes in three functions g1, g2, and g3 
# as arguments. "cyc" will return another function that should take in an integer
# argument n and return another function. That final function should take in an argument 
# x and cycle through applying g1, g2, and g3 to x, depending on what n was. 
# Here's what the final function should do to x for a few values of n:
# •	n = 0, return x
# •	n = 1, apply g1 to x, or return g1(x)
# •	n = 2, apply g1 to x and then g2 to the result of that, or return g2(g1(x))
# •	n = 3, apply g1 to x, g2 to the result of applying g1, and then g3 to the result of applying g2, or g3(g2(g1(x)))
# •	n = 4, start the cycle again applying g1, then g2, then g3, then g1 again, or g1(g3(g2(g1(x))))
# •	And so forth.

#*Hint: most of the work goes inside the most nested function.

#def  cyc(g1, g2, g3):
""" Returns a function that is itself a higher order function
    >>> def add_one(x):
    ...        return x + 1

    >>> def times_two(x):
    ...        return x * 2

    >>> def add_three(x):
    ...        return x + 3

    >>> my_cyc = cyc(add_one, times_two, add_three)
    >>> h= my_cyc(0)
    >>> h(5)
    5

    >>> h = my_cyc(2)
    >>> h(1)		# times_two (add_one (1))
    4							
    >>> h = my_cyc(3)        
    >>> h(2)		# add_three (times_two (add_one (2)))
    9

    >>> h = my_cyc(4)
    >>> h(2)		# add_one (add_three (times_two (add_one (2))))
    10

    >>> h = my_cyc(6)
    >>> h(1)
    19	   #add_three(times_two (add_one (add_three (times_two (add_one (1))))))
    """
#ANS
def add_one(x):
   return x + 1

def times_two(x):
   return x * 2

def add_three(x):
   return x + 3

def  cyc(g1, g2, g3):
    def func(n):
      def funch(x):
          nonlocal n
          if n == 0:
              return x 
          elif n == 1:
              return g1(x)
          elif n==2:
               return g2(g1(x))
          else: 
               n-=3
               return funch(g3(g2(g1(x)))) 
      return funch
    return func
my_cyc = cyc(add_one, times_two, add_three)
h= my_cyc(0)
print(h(5))

h = my_cyc(2)
print(h(1))

h= my_cyc(3)        
print(h(2))

h = my_cyc(4)
print(h(2))

h = my_cyc(6)
print(h(1))

"""[](https://drive.google.com/file/d/1Ox7Gd5cIKgVPukyoZOnRz9nfPp8bm_kf/view?usp=sharing)"""