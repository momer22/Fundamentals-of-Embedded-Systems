# -*- coding: utf-8 -*-
"""19660_Mahmud_Omer_hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cJa-GwNwtXyEwKHt60SDh5NsP_Qa6tQM
"""

# 1.	Write a high order function to make withdrawal from the balance in bank account by nonlocal variable.
# def mk_wd(balance):
"""
    Return the balance after withdrawal since inception
    >>> rem = mk_wd (100)         # deposit $100 
    >>> rem(10)
    90
    >>> rem (20)
    70
    >>> rem (100)
   'Insufficient funds'
   """
#ANS 
def mk_wd(balance):
  b = balance 
  def rem(x):
    nonlocal b
    if (b-x)>=0:
      b = b-x 
      return b
    else:
      return "'Insufficient funds'"
      
  return rem
  
rem = mk_wd (100) 
print(rem(10))
print(rem (20))
print(rem (100))

#2.	Write a function that deletes all instances of an element from a list. 
#def  rm_all(elem, lst): 
""" 
>>> x = [3, 1, 2, 1, 5, 1, 1, 7] 
>>> rm_all (1, x) 
>>> x 
[3, 2, 5, 7] 
"""
def  rm_all(elem, lst):
   global x
   count = 0
   for element in lst:
     if element == elem:
       count+=1
   for i in range(count):
     lst.remove(elem)
   x = lst
   
x = [3, 1, 2, 1, 5, 1, 1, 7] 
rm_all (1, x) 
x

#3. Write a function that takes in three arguments x, elem, and a list, and adds as many "elem"s to the end of the list as there are xâ€™s. 
#def add_many(x, elem, lst): 
""" 
Adds elem to the end of lst the number of times x occurs in lst. 
>>> lst = [1, 2, 4, 2, 1] 
>>> add_many (2, 5, lst) 
>>> lst
[1, 2, 4, 2, 1, 5, 5] 
"""
#ANS
def add_many(x, elem, list):
   global lst
   for i in range(x):
      lst.append(elem)
lst = [1, 2, 4, 2, 1] 
add_many (2, 5, lst)
lst

#4. Write a function to create a new list from given a "suits" list and a number list

#def  f (suits, numbers):
"""Creates a new list (2-element list as one element in a new list) with the given suits and numbers. Each element in the returned list should be of the form [suit, number].
    >>> f (['S', 'C'], [1, 2, 3])
    [['S', 1], ['S', 2], ['S', 3], ['C', 1], ['C', 2], ['C', 3]]
    >>> f (['S', 'C'], [3, 2, 1])
    [['S', 3], ['S', 2], ['S', 1], ['C', 3], ['C', 2], ['C', 1]]
    >>> f ([], [3, 2, 1])
    []
    >>> f (['S', 'C'], [])
    []
"""
#ANS
def  f (suits, numbers):
  combined = []
  if len(suits)== 0 or len(numbers)== 0:
     return combined 
  else: 
    for i in range(len(suits)):
      for j in range(len(numbers)):
           combined.append([suits[i],numbers[j]])
    return combined 

print(f (['S', 'C'], [1, 2, 3]))
print(f (['S', 'C'], [3, 2, 1]))
print(f ([], [3, 2, 1]))
print(f (['S', 'C'], []))

#5. Write a function to merge 2 sorted lists a and b, and then return a new list with a sorted order by RECURSIVE calls.

#def mrg(ls1, ls2):
"""Merges two sorted lists recursively.

    >>> mrg ([1, 3, 5], [2, 4, 6])
    [1, 2, 3, 4, 5, 6]
    >>> mrg ([], [2, 4, 6])
    [2, 4, 6]
    >>> mrg ([1, 2, 3], [])
    [1, 2, 3]
    >>> mrg ([5, 7], [2, 4, 6])
    [2, 4, 5, 6, 7]
    """
#ANS
def mrg(ls1, ls2):
  lst = []
  size_1 = len(ls1)
  size_2 = len(ls2)
    
  merged_lst = []
  i, j = 0, 0
    
  while i < size_1 and j < size_2:
      if ls1[i] < ls2[j]:
        merged_lst.append(ls1[i])
        i += 1
      else:
        merged_lst.append(ls2[j])
        j += 1
    
  merged_lst = merged_lst + ls1[i:] + ls2[j:]
  return merged_lst

print(mrg ([1, 3, 5], [2, 4, 6]))
print(mrg ([1, 2, 3], []))
print(mrg ([], [2, 4, 6]))
print(mrg ([5, 7], [2, 4, 6]))

#6. Write the function to flatten the deep list.

#def fltn(ls):
"""Return a new version of list as follows.

    >>> fltn ([1, 2, 3])     		    # normal list
    [1, 2, 3]
    >>> x = [1, [2, 3], 4]      		# deep list
    >>> fltn (x)
    [1, 2, 3, 4]
    >>> x = [[1, [1, 1]], 1, [1, 1]]# deep list
    >>> fltn (x)
    [1, 1, 1, 1, 1, 1]
"""
#

def fltn(ls):
    flatten = []
    isDeep = False
    for elem in ls:
      if type(elem) is list:
        isDeep = True 
    if isDeep:
      for elem in ls:
          if type(elem) is list:
            for item in elem:
              flatten.append(item)
          else: 
              flatten.append(elem)
    elif isDeep == False:
        return ls     
    return fltn(flatten) 
  
print(fltn ([1, 2, 3]))
x = [1, [2, 3], 4] 
print(fltn (x))
x = [[1, [1, 1]], 1, [1, 1]]
print(fltn (x))

#7. Define a function to check if the element exists in the list or not.

#def   chk_elm(lst, n): 
"""
>>> a = [ [1,[2]], 3, [ [4], [5,[6] ] ]   ] 
>>> chk_elm (a, 6)
True
"""
#ANS
def   chk_elm(lst, n): 
  exists = False 
  for elem in lst:
        if isinstance(elem, list):
            if chk_elm(elem, n):
                return True
        elif elem == n:
            return True
  return False
a = [ [1,[2]], 3, [ [4], [5,[6] ] ]   ] 
print(chk_elm (a, 6))
print(chk_elm (a, 9))

#8. Write a function to check whether the input argument list is symmetric or not in recursive call.
#def sym(l):
"""Returns whether a list is symmetric or not
    >>> sym ([])
    True
    >>> sym ([1])
    True
    >>> sym ([1, 4, 5, 1])
    False
    >>> sym ([1, 4, 4, 1])
    True
    >>> sym (['l', 'o', 'l'])
    True
    """
#ANS
def sym(ls):
  l = 0
  h = len(ls)-1
  while l<h:
     if ls[l] !=ls[h]:
       return False 
     l+=1
     h-=1
  return True 
print(sym ([]))
print(sym ([1]))
print(sym ([1, 4, 5, 1]))
print(sym ([1, 4, 4, 1]))
print(sym (['l', 'o', 'l']))

#9. Write a function in recursive call that takes in a list lst, 
# a function g, and an initial value m. This function will fold lst 
# starting at the beginning. If lst is [1, 2, 3, 4, 5] then the function
#  g is applied as follows:

#g (g (g (g (g (m, 1), 2), 3), 4), 5)
# from operator import add, sub, mul
# def fld (lst, g, m):
"""Return the result of applying the function g to the initial value m     and the first element in lst, and repeatedly applying g to this result and the next element in lst until it reaches the end of the list.

    >>> s = [3, 2, 1]
    >>> fld (s, sub, 0)      	# sub(sub(sub(0, 3), 2), 1)
    -6
    >>> fld (s, add, 0)      	# add(add(add(0, 3), 2), 1)
    6
    >>> fld (s, mul, 1)      	# mul(mul(mul(1, 3), 2), 1)
    6

    >>> fld ([], sub, 100)   	# return m if s is empty
    100
   """
#from operator import add, sub, mul
def add(a, b):
  return a + b
def sub(a , b):
  return a - b
def mul(a,b):
  return a*b

def fld (lst, g, m):
    if len(lst) == 0:
        return m 
    else:
        m = g(m , lst[0])
        lst.pop(0) 
        return fld( lst, g ,m)

s = [3, 2, 1]
print(fld (s, sub, 0))

#*******************************************************************
s = [3, 2, 1]
print(fld (s,  add, 0))

#*******************************************************************
s = [3, 2, 1]
print(fld (s,   mul, 1))

#*******************************************************************
s = [3, 2, 1]
print(fld ([],   sub, 100))

#10. Implement a function to create 2D array as follows
#def   crte_2d_arr(rows, columns):
"""
>>> crte_2d_arr(3, 5)
[['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-']]
"""
# ANS
def   crte_2d_arr(rows, columns):
     arr = [[0]*columns]*rows
     for i in range(rows):
       for j in range(columns):
         arr[i][j] = "-"
     return arr
crte_2d_arr(3, 5)