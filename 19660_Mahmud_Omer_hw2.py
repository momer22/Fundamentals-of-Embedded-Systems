# -*- coding: utf-8 -*-
"""hw2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UifsmfVyhQ5i_kWzzI105aOdz0NFsDqi
"""

#1.	Define a function to implement the following operations

#def fancy_printing (n):
""" A function that prints numbers in a specified
range except those divisible by n, and print it with “Buzz!”

Assume that the following example is to print numbers from 0 to (10-1), 
  and print “Buzz!” at the location of the number divisible by 5   

>>> replace = fancy_printing (5)
>>> replace(10)                                
0
Buzz!
2
3
4
Buzz!
6
7
8
9
"""
#Solution
def fancy_printing (n):
    out_put = []
    for i in range(10):
        if i == 0:
          out_put.append(0)
        elif n%i== 0:
           out_put.append("Buzz!")
        else:
           out_put.append(i)
    return out_put
  
replace = fancy_printing (5)
print(replace)

#2.	Write a function to add every other number from 0 or 1 until input parameter n in function RECURSION only. 
# def   sum_num(n): 
""" Return the sum of every other natural number up to n, inclusive. 
>>> sum_num (4) 		# 0 + 2 + 4 
6 
>>> sum_num (5) 		# 1 + 3 + 5 
9 
"""
#ANS
def sum_num(n):
    sum = 0
    if n%2 == 0:
      initial = 0
      while(initial<=n):
          sum +=initial
          initial+=2
    else:
      initial = 1
      while(initial<=n):
          sum +=initial
          initial+=2
    print("sum = ", sum)

sum_num(4)
sum_num(5)

#3.	Define a function cnt_primes(m), where m is a positive integer and returns the number of prime integers from 1 to m in function RECURSION only, given that a function is_prime(n) has been defined. 
""">>> cnt_primes(6) 		# 1, 2, 3, 4, 5, 6 
>>> 3  			# 3 prime numbers from 1 to 6 
"""


def is_prime(n, i=2):
    if n <= i:
        return True
    elif n % i == 0:
        return False
    else:
       return is_prime(n, i + 1)

def cnt_primes(n):
    count=0
    i = 2
    while(i<=n):
         if is_prime(i):
           count+=1
         i+=1
    print("# of prime numbers = ",count)
cnt_primes(5)

#4.	If "f" is a function and n is a positive integer, then we can form the nth repeated application of f, which is defined to be the function whose value at x is f(f(...(f(x))). For example, if f adds 1 to its argument, then the nth repeated application of f adds n. Write a function that takes as inputs a function f and a positive integer n, and then returns the function that computes the nth repeated application of f:

#def foo(f, n):
"""Return the function that computes the nth application of f.
    >>>  incr(5)	       # function is to add 1 for input argument number
    6

    >>> add3 = foo (incr, 3) 
    >>> add3(5)        		# Doing like: incr(incr(incr(incr(incr(3)))))      
    8
    >>> foo (triple, 5)(1)  	# triple(triple(triple(triple(triple(1)))))
    243
    >>> foo (square, 2)(5) 	# square(square(5))
    625
    >>> foo (square, 4)(5) 	# square(square(square(square(5))))
    152587890625
"""

def incr(n):
    return n+1
def triple(n):
    return 3*n
def square(n):
  return n*n

def foo(f,n):
    if n == 1:
        return f
    return lambda x: f(foo(f, n-1)(x))

print(incr(5))

add3 = foo(incr,3)
print(add3(5))

print(foo (triple, 5)(1))

print(foo (square, 2)(5))

print(foo (square, 4)(5))

#5.	Calculate "ab+c" operation by function RECURSION. Other method can’t be allowed, only recursion function call. 
# def 	op(a, b, c): 

"""Computes a * b + c
  >>> op (2, 4, 3) 		# 2 * 4 + 3 
  11 
  >>> op (0, 3, 2) 		# 0 * 3 + 2 
  2 
  >>> op (3, 0, 2) 		# 3 * 0 + 2 
  2 
"""
def op(a, b, c): 
  if a == 0 or b == 0: 
    return c
  if a-1 == 0:
      return b+c
  return b+op(a-1, b, c) 

print(op(2, 4, 3))

print(op(0, 3, 2))

print(op(3, 0, 2))

#6.	Implement the function "checking", which takes a positive integer as input and returns True if its digits, read left to right, are in non-decreasing order, and False otherwise. For example, the digits of 5, 11, 127, and 1357 are ordered, but not those of 21 or 1375.
#def  checking(x):
"""Return True if the (base 10) digits of X>0 are in non-decreasing
    order, and False otherwise.

    >>> checking (5)
    True
    >>> checking (11)
    True
    >>> checking (127)			# 1<2<7
    True
    >>> checking (1357)			# 1<3<5<7
    True
    >>> checking (21)				# 2 > 1
    False
    >>> result = checking (1375) 		# 7 > 5	
    >>> result
    False
    """
# ANS 
def checking(n):
    if n<=0:
        print("Number should be positive integer ")
        return 
    else: 
      while (n>=1):
          a = n%10
          b = (n//10)%10
          if a >= b:
              output = True 
              n//=10
          else:
             output = False
             break 
    return output 
print(checking(5))
print(checking(11))
print(checking(127))
print(checking(1357))
print(checking(21))
result = checking(1372)
print(result)

#7.	Define a function to implement the following operation in RECURSIVE call only.

# def   cal(n): 

"""Return the product of n * (n - 2) * (n - 4) * ... 
  >>> cal (5) 		# 5 * 3 * 1 
  15 
  >>> cal (8) 		# 8 * 6 * 4 * 2 * 0 
  0	
  """
#ANS 
def   cal(n):
    if n%2 == 0 and n <= 1:
      return 0
    elif n%2 == 1 and n <= 1:
      return 1

    elif n%2 == 0:
      return n*cal(n-2)
    return n*cal(n-2)

print(cal(5))
print(cal(8))

#8.	Define a function to implement intersects, which takes a one-argument function f and argument "x", returns a function g. It returns True if f(x)=g(x), otherwise False.

#def 	intscts(f, x):

"""Returns a function that returns whether f intersects g at x.

    >>> at3 = intscts(square, 3)
    >>> at3 (triple) 				# triple(3) == square(3)
    True
    >>> at3 (increment)			# triple(3) != square(3) 
    False
    >>> at1 = intscts(identity, 1)
    >>> at1(square)				# square(1) == identity(1)
    True
    >>> at1 (triple)				# triple(1) != identity(1)
    False
    """
#ANS
def incr(n):
    return n+1
def triple(n):
    return 3*n
def square(n):
  return n*n

def intscts(f,n):
    if n == 1:
       if f(n) == g(n):
         return True
       else:
         return False 
    g = lambda x: f(intscts(f, n-1)(x))

at3 = intscts(square,3)
at3(triple)

# 9.	Assume a mathematical function A(x), where x is positive number is defined by two cases: 
#A(n) = n, 					if n <= 3 
#A(n) =A(n - 1) + 2 * A(n - 2) + 3 * A(n - 3), 	if n > 3 

#def 	A(n): 
"""Return the value of A(n), calculate in RECURSIVE call only
   >>> A(1) 
   1 
   >>> A(2) 
   2 
   >>> A (3) 
   3 
   >>> A (4) 		# A (3) + 2* A (2) + 3* A (1) = 3 + 2*2 + 3*1=10 
   10
   >>> A (5) 		# A (4) + 2* A (3) + 3* A (2)=10 + 2*3 + 3*2 = 22 
                            22
  """

# ANS 

def  A(n): 
    if n <= 3:
      return n
    else:
      return A(n - 1) + 2 * A(n - 2) + 3 * A(n - 3)

print(A(1))
print(A(2))
print(A(3))
print(A(4))
print(A(5))

#10.	The bounce-back-forth sequence is a serial number from 1 and is always either counting up or counting down. In kth number, 
# the direction changes when k is divisible by 7 or contains the digit 7. The first 30 elements of the bounce-back-forth sequence are listed below,
# with direction change marked in RED color at the 7th, 14 th, 17 th, 21st, 27 th, and 28 th elements: 

#Index number in the serial: 1 2 3  4  5 6  7   8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  28  29 30
#                            1 2 3 4 5 6 [7] 6 5 4  3  2  1  [0] 1  2 [3] 2  1  0 [-1] 0 1   2  3  4  [5] [4] 5  6 

#Write a function bounce-back-forth that returns the kth element of the bounce-back-forth sequence. 

#def 	bnc_bck_frth(k): 

"""Return the kth element of the bounce-back-forth sequence. 
  >>> bnc_bck_frth (7) 
   7 
  >>> bnc_bck_frth (8) 
  6 
  >>> bnc_bck_frth (15) 
  1 
  >>> bnc_bck_frth (21) 
 -1 
  >>> bnc_bck_frth (22) 
  0 
  >>> bnc_bck_frth (30) 
  6 """

#ANS
def bnc_bck_frth(n):
    k = 1
    assending = True 
    num_found = False 
    for i in range (1, n):
        #print(k)
        j = i
        while(j!=0):
          if i%10 ==7:
            num_found = True 
            break
          j //=10
        #print(num_found)
        if i%7 == 0 or num_found==True:
            num_found = False
            if assending == True: 
                assending = False 
            else:
                assending = True 
        if assending == True:
            k +=1
        else:
            k -=1
    return k
print(bnc_bck_frth (7))
print(bnc_bck_frth (8))
print(bnc_bck_frth (15))
print(bnc_bck_frth (21))
print(bnc_bck_frth (22))
print(bnc_bck_frth (30))